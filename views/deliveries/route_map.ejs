<% locals.pageTitle = typeof title !== 'undefined' ? title : 'Optimized Delivery Route' %>

<header class="py-3 px-6 border-b border-gray-200 bg-white shadow-sm flex-shrink-0">
     <div class="flex items-center justify-between">
         <h2 class="text-lg font-semibold text-gray-800"><%= locals.pageTitle %></h2>
         <div>
             <a href="/deliveries/my" class="inline-block px-3 py-1.5 border border-gray-300 text-xs font-medium text-gray-700 rounded-md hover:bg-gray-50">
                 Back to List
             </a>
         </div>
     </div>
</header>

<%# Display errors from routing API if any %>
<% if (typeof errorMsg !== 'undefined' && errorMsg) { %>
    <div class="m-6 bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative max-w-4xl mx-auto" role="alert">
        <strong class="font-bold">Routing Error!</strong>
        <span class="block sm:inline"><%= errorMsg %></span>
    </div>
<% } %>
<section class="p-6 flex-1 grid grid-cols-1 lg:grid-cols-3 gap-6 overflow-hidden">
  <div class="lg:col-span-2 h-[calc(100vh-150px)]">
    <div id="route-map" class="w-full h-full border rounded-lg bg-gray-200 flex items-center justify-center relative">
      <div id="map-loader" class="absolute inset-0 bg-gray-200 bg-opacity-75 flex items-center justify-center z-10">
        <!-- loader SVG -->
      </div>
    </div>
  </div>

  <div class="lg:col-span-1 h-[calc(100vh-150px)] overflow-y-auto bg-white border rounded-lg shadow-sm p-4 space-y-3">
    <h3 class="text-base font-semibold text-gray-700 border-b pb-2 mb-3">Optimized Route Legs</h3>

    <% if (routeLegs && routeLegs.length) { %>
      <% routeLegs.forEach((leg, idx) => { %>
        <div class="border p-3 rounded-md bg-gray-50">
          <p class="text-xs text-gray-500">Distance: <%= (leg.distance/1000).toFixed(2) %> km | Duration: <%= Math.ceil(leg.duration/60) %> min</p>
          <p class="font-semibold text-sm mt-1">From: <%- leg.startName %></p>
          <p class="text-xs text-gray-600"><%- leg.startAddress %></p>
          <p class="font-semibold text-sm mt-2">To: <%- leg.endName %></p>
          <p class="text-xs text-gray-600"><%- leg.endAddress %></p>

          <button
            class="start-route-btn mt-3 text-blue-600 hover:underline text-xs"
            data-start='<%= JSON.stringify(leg.startCoords) %>'
            data-end='<%= JSON.stringify(leg.endCoords) %>'
          >Start</button>
        </div>
      <% }) %>
    <% } else { %>
      <p class="text-sm text-gray-500 text-center py-4">No route legs available.</p>
    <% } %>
  </div>
</section>

<script src="https://maps.googleapis.com/maps/api/js?key=<%= googleMapsApiKey %>&libraries=geometry,marker&callback=initRouteMap" async defer></script>

<script>
  let map, legPolyline;
  const loader = document.getElementById('map-loader');

  function initRouteMap() {
    // existing map init logic to draw full routePolyline...
    // then attach handlers:
    document.querySelectorAll('.start-route-btn').forEach(btn => {
      btn.addEventListener('click', async () => {
        if (legPolyline) legPolyline.setMap(null);
        loader.style.display = 'flex';
        const start = JSON.parse(btn.getAttribute('data-start'));
        const end = JSON.parse(btn.getAttribute('data-end'));
        try {
          const res = await fetch(
            `http://router.project-osrm.org/route/v1/driving/${start.lng},${start.lat};${end.lng},${end.lat}?overview=full&geometries=polyline`
          );
          const data = await res.json();
          if (data.code !== 'Ok') throw new Error(data.message || data.code);
          const geom = data.routes[0].geometry;
          const path = google.maps.geometry.encoding.decodePath(geom);
          legPolyline = new google.maps.Polyline({
            path, map, strokeWeight: 6, strokeOpacity: 0.8
          });
          // adjust viewport
          const bounds = new google.maps.LatLngBounds();
          path.forEach(p => bounds.extend(p));
          map.fitBounds(bounds);
        } catch (e) {
          console.error('Error fetching leg route:', e);
        } finally {
          loader.style.display = 'none';
        }
      });
    });
  }
</script>
<script src="https://maps.googleapis.com/maps/api/js?key=<%= typeof googleMapsApiKey !== 'undefined' ? googleMapsApiKey : '' %>&libraries=geometry,marker&callback=initRouteMap" async defer></script>

<script>
    let map;
    const loader = document.getElementById('map-loader');
    const mapDiv = document.getElementById('route-map');

    // Safely get data passed from server
    const rawRoutePolyline =      '<%= typeof routePolyline !== "undefined" ? JSON.stringify(routePolyline) : "null" %>';
    const rawAssignedOrders =     '<%= typeof orders !== "undefined" ? JSON.stringify(orders) : "[]" %>'; // These are REORDERED by backend
    const rawOriginWarehouse =    '<%= typeof originWarehouse !== "undefined" ? JSON.stringify(originWarehouse) : "null" %>';

    let routePolyline = null;
    let ordersList = [];
    let originDetails = null;

    function parseServerData() {
        try {
            console.log("Parsing server data...");
            routePolyline = JSON.parse(rawRoutePolyline); // This will be the OSRM encoded polyline string (or null)
            ordersList = JSON.parse(rawAssignedOrders);   // These are already in OSRM/NN optimized order
            originDetails = JSON.parse(rawOriginWarehouse);
            console.log("Parsed data:", { routePolylineExists: !!routePolyline, ordersCount: ordersList.length, originExists: !!originDetails });
            return true;
        } catch (e) {
            console.error("Error parsing server data:", e);
            if(mapDiv) mapDiv.innerHTML = '<p class="text-center p-4 text-red-600">Error processing route data from server.</p>';
            if(loader) loader.style.display = 'none';
            return false;
        }
    }

    async function initRouteMap() {
        console.log("Attempting initRouteMap() for OSRM route display...");
        if (!parseServerData()) {
             console.log("Halting map initialization due to parsing error.");
             return;
        }

        try {
            if (typeof google === 'undefined' || !google.maps?.Map || !google.maps?.geometry?.encoding || !google.maps?.marker?.AdvancedMarkerElement) {
                 throw new Error("Google Maps script/libraries (Map, Marker, Geometry) did not load properly.");
            }

            const { Map, InfoWindow, LatLngBounds, Polyline } = await google.maps.importLibrary("maps");
            const { AdvancedMarkerElement } = await google.maps.importLibrary("marker");
            const { encoding } = await google.maps.importLibrary("geometry"); // For decoding OSRM polyline
            console.log("Google Maps Libraries Loaded for OSRM display");

            let mapCenter = { lat: 12.9716, lng: 77.5946 }; // Default
            if (originDetails?.location?.coordinates?.length === 2) {
                mapCenter = { lat: parseFloat(originDetails.location.coordinates[1]), lng: parseFloat(originDetails.location.coordinates[0]) };
            } else if (ordersList[0]?.shippingLocation?.coordinates?.length === 2) {
                 const firstOrderLoc = ordersList[0].shippingLocation.coordinates;
                 mapCenter = { lat: parseFloat(firstOrderLoc[1]), lng: parseFloat(firstOrderLoc[0]) };
            }
            console.log("Map Center:", mapCenter);

            map = new Map(mapDiv, { center: mapCenter, zoom: 11, mapId: "SWIFTROUTE_DELIVERY_MAP" });
            mapDiv.classList.remove('flex', 'items-center', 'justify-center');
            mapDiv.textContent = '';
            if(loader) loader.style.display = 'none';
            console.log("Map initialized.");

            const bounds = new google.maps.LatLngBounds();

            // Add Origin Marker
            if (originDetails?.location?.coordinates?.length === 2) {
                const originLat = parseFloat(originDetails.location.coordinates[1]);
                const originLng = parseFloat(originDetails.location.coordinates[0]);
                if (!isNaN(originLat) && !isNaN(originLng)) {
                    const originPos = { lat: originLat, lng: originLng };
                    const originMarkerContent = document.createElement('div');
                    originMarkerContent.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-8 h-8 text-red-600"><path fill-rule="evenodd" d="M4 4a2 2 0 012-2h8a2 2 0 012 2v12a1 1 0 110 2h-3v-7a1 1 0 00-1-1H9a1 1 0 00-1 1v7H5a1 1 0 110-2V6H4V4zm10 4V6h-2v2h2zM8 8V6H6v2h2z" clip-rule="evenodd" /></svg>`;
                    new AdvancedMarkerElement({ map, position: originPos, title: `${originDetails.name} (Warehouse)`, content: originMarkerContent, zIndex: 1 });
                    bounds.extend(originPos);
                    console.log("Origin marker added at:", originPos);
                }
            }

            // Add Destination Markers (using ordersList which is already sorted by backend)
            ordersList.forEach((order, index) => {
                const deliveryLocData = order.shippingLocation?.coordinates?.length === 2 ? order.shippingLocation : order.storeId?.location;
                if(deliveryLocData?.coordinates?.length === 2){
                    const destLat = parseFloat(deliveryLocData.coordinates[1]);
                    const destLng = parseFloat(deliveryLocData.coordinates[0]);
                    if (!isNaN(destLat) && !isNaN(destLng)) {
                        const pos = { lat: destLat, lng: destLng };
                        const marker = new AdvancedMarkerElement({
                            map, position: pos, zIndex: index + 2,
                            title: `Stop ${index + 1}: ${order.customerName || order.storeId?.storeName || 'Delivery'}`,
                            content: buildMarkerContent(index + 1)
                         });
                        const infoContent = `<b>Stop ${index + 1}: ${order.customerName || 'Delivery'}</b><br>${order.shippingAddress || ''}${order.storeId?.storeName ? '<br>(Store: '+order.storeId.storeName+')' : ''}`;
                        const info = new InfoWindow({ content: infoContent });
                        marker.addListener('click', () => info.open({ map: map, anchor: marker }));
                        bounds.extend(pos);
                    }
                } else { console.warn(`Skipping marker for order ${order._id} (no valid coords).`); }
            });
            console.log(`Added ${ordersList.length} destination markers.`);

            // Draw Polyline from OSRM
            if (routePolyline) { // This is the geometry string from OSRM
                console.log("Decoding and drawing OSRM route polyline...");
                try {
                    const decodedPath = google.maps.geometry.encoding.decodePath(routePolyline);
                    new Polyline({ path: decodedPath, map: map, strokeColor: '#007bff', strokeWeight: 6, strokeOpacity: 0.7 });
                    console.log("OSRM Route polyline drawn.");
                } catch (polyError) { console.error("Error decoding/drawing OSRM polyline:", polyError); }
            } else { console.log("OSRM route polyline not available."); }

            if (ordersList.length > 0 && !bounds.isEmpty()) {
                map.fitBounds(bounds);
                google.maps.event.addListenerOnce(map, 'idle', () => { map.panToBounds(bounds, {top: 50, bottom: 50, left: 50, right: 50}); });
            } else if (originDetails && !bounds.isEmpty()){ // Only origin shown
                 map.setCenter(bounds.getCenter()); map.setZoom(14);
            } else { mapDiv.innerHTML = '<p class="text-center p-4">No locations to display on map.</p>'; if(loader) loader.style.display = 'none';}

        } catch (err) {
             console.error("Error initializing map:", err);
             mapDiv.innerHTML = `<p class="text-center p-4 text-red-600">Error loading map: ${err.message}</p>`;
             if(loader) loader.style.display = 'none';
        }
    }

    function buildMarkerContent(stopNumber) {
         const element = document.createElement('div');
         element.className = 'w-6 h-6 bg-blue-600 text-white rounded-full flex items-center justify-center text-xs font-bold border-2 border-white shadow drop-shadow';
         element.textContent = stopNumber;
         return element;
    }
</script>